<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Human Anatomy Explorer | Interactive Learning Games</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Rajdhani:wght@400;500;600;700&family=Roboto:wght@300;400;500&display=swap">
  <!-- React and Babel scripts -->
  <script src="https://unpkg.com/react@17/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@17/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
    /* Custom Science/Space Theme */
    :root {
      --primary: #4F46E5;
      --primary-hover: #4338CA;
      --secondary: #10B981;
      --accent: #06B6D4;
      --dark-bg: #111827;
      --panel-bg: #1F2937;
      --text-primary: #F9FAFB;
      --text-secondary: #D1D5DB;
      --glow-primary: 0 0 15px rgba(99, 102, 241, 0.5);
      --glow-secondary: 0 0 15px rgba(16, 185, 129, 0.5);
    }
    body {
      font-family: 'Roboto', sans-serif;
      margin: 0;
      overflow: hidden;
      background-color: var(--dark-bg);
      color: var(--text-primary);
    }
    h1, h2, h3, h4, h5, h6 {
      font-family: 'Rajdhani', sans-serif;
      font-weight: 600;
    }
    .sci-panel {
      background-color: rgba(31, 41, 55, 0.85);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(99, 102, 241, 0.2);
      border-radius: 0.5rem;
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06), var(--glow-primary);
    }
    .sci-title {
      position: relative;
      overflow: hidden;
    }
    .sci-title::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 5px;
      height: 100%;
      background: linear-gradient(180deg, var(--primary), var(--secondary));
    }
    .sci-badge {
      background: linear-gradient(45deg, var(--primary), var(--accent));
      color: white;
      padding: 0.25rem 0.75rem;
      border-radius: 9999px;
      font-size: 0.75rem;
      font-weight: 500;
    }
    .sci-highlight {
      color: var(--secondary);
      font-weight: 500;
    }
    .glow-text {
      text-shadow: 0 0 8px rgba(99, 102, 241, 0.6);
    }
    /* Canvas Styling */
    #canvas-container {
      flex-grow: 1;
      height: 100vh;
      position: relative;
    }
    #canvas-container canvas {
      display: block;
      width: 100%;
      height: 100%;
      cursor: grab;
    }
    #canvas-container canvas:active {
      cursor: grabbing;
    }
    /* Sidebar Panel */
    #info-panel {
      width: 375px;
      height: 100vh;
      overflow-y: auto;
      flex-shrink: 0;
      background-color: var(--panel-bg);
      transition: transform 0.3s ease;
      scrollbar-width: thin;
      scrollbar-color: var(--primary) var(--panel-bg);
    }
    #info-panel::-webkit-scrollbar {
      width: 8px;
    }
    #info-panel::-webkit-scrollbar-track {
      background: var(--panel-bg);
    }
    #info-panel::-webkit-scrollbar-thumb {
      background-color: var(--primary);
      border-radius: 20px;
    }
    /* Loading Overlay */
    #loading-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: rgba(17, 24, 39, 0.95);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 50;
    }
    .progress-bar {
      width: 300px;
      height: 8px;
      background-color: rgba(255, 255, 255, 0.1);
      border-radius: 4px;
      overflow: hidden;
      margin-top: 2rem;
    }
    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, var(--primary), var(--secondary));
      width: 0%;
      transition: width 0.3s ease;
      box-shadow: var(--glow-primary);
    }
    /* Controls Guide */
    #controls-guide {
      position: absolute;
      bottom: 1rem;
      right: 1rem;
      background-color: rgba(31, 41, 55, 0.8);
      color: white;
      font-size: 0.75rem;
      line-height: 1.25rem;
      padding: 0.75rem;
      border-radius: 0.5rem;
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
      z-index: 10;
      max-width: 250px;
      backdrop-filter: blur(8px);
      border: 1px solid rgba(99, 102, 241, 0.15);
      transition: opacity 0.3s;
      opacity: 0.7;
    }
    #controls-guide:hover {
      opacity: 1;
    }
    /* HUD Elements */
    .hud-element {
      position: absolute;
      pointer-events: none;
      z-index: 5;
      font-family: 'Rajdhani', sans-serif;
    }
    .body-stat {
      top: 1rem;
      left: 1rem;
      font-size: 0.8rem;
      padding: 0.75rem;
      color: var(--text-secondary);
      max-width: 250px;
    }
    .body-scan-line {
      position: absolute;
      width: 100%;
      height: 4px;
      background: linear-gradient(90deg, 
          transparent, 
          rgba(99, 102, 241, 0.2), 
          rgba(99, 102, 241, 0.5), 
          rgba(99, 102, 241, 0.2), 
          transparent);
      z-index: 10;
      pointer-events: none;
      box-shadow: 0 0 15px rgba(99, 102, 241, 0.4);
      opacity: 0;
      animation: scanAnimation 8s infinite;
    }
    @keyframes scanAnimation {
      0% { top: 0%; opacity: 1; }
      90% { top: 100%; opacity: 1; }
      91% { opacity: 0; }
      100% { top: 0%; opacity: 0; }
    }
    /* HUD Trackers */
    .tracker {
      position: absolute;
      width: 80px;
      height: 80px;
      pointer-events: none;
      z-index: 5;
      border: 1px solid rgba(99, 102, 241, 0.5);
      border-radius: 50%;
      transform: translate(-50%, -50%);
      background: radial-gradient(circle, 
          rgba(99, 102, 241, 0.15) 0%, 
          rgba(16, 185, 129, 0.05) 70%, 
          transparent 100%);
      box-shadow: 0 0 15px rgba(99, 102, 241, 0.3);
      opacity: 0;
      transition: opacity 0.5s;
    }
    .tracker::before, .tracker::after {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      border-radius: 50%;
    }
    .tracker::before {
      width: 60px;
      height: 60px;
      border: 1px dashed rgba(99, 102, 241, 0.5);
      animation: rotate 10s linear infinite;
    }
    .tracker::after {
      width: 10px;
      height: 10px;
      background-color: rgba(16, 185, 129, 0.8);
      box-shadow: 0 0 8px rgba(16, 185, 129, 0.8);
    }
    @keyframes rotate {
      from { transform: translate(-50%, -50%) rotate(0deg); }
      to { transform: translate(-50%, -50%) rotate(360deg); }
    }
    /* Augmented Reality Styled Labels */
    .ar-label {
      position: absolute;
      color: var(--secondary);
      font-size: 0.7rem;
      letter-spacing: 0.05em;
      pointer-events: none;
      z-index: 5;
      transition: opacity 0.5s;
      opacity: 0;
      text-shadow: 0 0 5px var(--secondary);
    }
    .ar-label::after {
      content: '';
      position: absolute;
      top: 50%;
      width: 30px;
      height: 1px;
      background-color: var(--secondary);
      opacity: 0.5;
    }
    .ar-label-left {
      text-align: right;
    }
    .ar-label-left::after {
      right: -35px;
    }
    .ar-label-right {
      text-align: left;
    }
    .ar-label-right::after {
      left: -35px;
    }
    .info-card {
      opacity: 0;
      transform: translateY(20px);
      transition: opacity 0.5s, transform 0.5s;
    }
    .info-card.show {
      opacity: 1;
      transform: translateY(0);
    }
    /* Responsive Styles */
    @media (max-width: 768px) {
      .flex-col-reverse { flex-direction: column-reverse; }
      #info-panel {
        width: 100%;
        height: 40%;
        min-height: 250px;
        max-height: 50%;
      }
      #canvas-container {
        height: 60%;
      }
      .panel-toggle {
        display: block !important;
      }
      #info-panel.collapsed {
        transform: translateY(calc(100% - 40px));
      }
      #toggle-panel-icon {
        transform: rotate(0deg);
        transition: transform 0.3s;
      }
      #info-panel.collapsed #toggle-panel-icon {
        transform: rotate(180deg);
      }
    }

    /* Additional styles for games */
    .game-panel {
      max-width: 100%;
      height: 100%;
      overflow-y: auto;
      padding: 1rem;
    }
  </style>
</head>
<body>
  <!-- Loading Overlay -->
  <div id="loading-overlay">
    <h2 class="text-4xl font-bold text-center mb-2 glow-text">Loading Human Anatomy Explorer</h2>
    <p class="text-gray-400 mb-6">Preparing interactive learning games...</p>
    <div class="progress-bar">
      <div class="progress-fill" id="progress-bar"></div>
    </div>
    <p id="loading-text" class="mt-4 text-sm text-gray-300">Establishing connection...</p>
  </div>

  <div class="flex h-screen md:flex-row flex-col-reverse">
    <!-- Information Panel - Will be replaced with React games -->
    <div id="info-panel" class="relative">
      <!-- Mobile Toggle -->
      <button id="panel-toggle" class="panel-toggle hidden absolute top-4 right-4 md:hidden bg-gray-700 p-2 rounded-md hover:bg-gray-600 focus:outline-none">
        <svg id="toggle-panel-icon" xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
          <path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd" />
        </svg>
      </button>
      <!-- Header Section -->
      <div class="p-6">
        <div class="sci-title pl-6 mb-4">
          <h1 class="text-2xl font-bold">Human Anatomy Explorer</h1>
          <p class="text-sm text-gray-400">Interactive Learning Games</p>
        </div>
        <div class="flex items-center space-x-2 mb-4">
          <div class="sci-badge bg-indigo-700 text-indigo-50">
            <span class="opacity-60">GAME</span><span>HUB</span>
          </div>
          <div class="h-2 w-2 rounded-full bg-green-400 animate-pulse"></div>
          <div class="text-xs text-green-400">ACTIVE</div>
        </div>
      </div>
      <!-- Game Container - Will be populated by React -->
      <div id="game-container" class="px-6 pb-6">
        <div class="sci-panel p-4 info-card show">
          <p class="text-gray-300 text-sm">
            Welcome to the <span class="sci-highlight">Human Anatomy Explorer Games</span>.
            Click on different body parts to access interactive learning games.
          </p>
          <p class="text-gray-300 text-sm mt-2">
            <strong>Available Games:</strong>
          </p>
          <ul class="text-gray-300 text-sm mt-1 space-y-1">
            <li>• <span class="text-indigo-300">Head</span> - Memory Test</li>
            <li>• <span class="text-indigo-300">Chest</span> - Pulse Test</li>
            <li>• <span class="text-indigo-300">Abdomen</span> - BMI Calculator</li>
            <li>• <span class="text-indigo-300">Arms</span> - Reaction Test</li>
            <li>• <span class="text-indigo-300">Legs</span> - Balance Test</li>
          </ul>
        </div>
      </div>
    </div>

    <!-- 3D Canvas Container -->
    <div id="canvas-container" class="relative">
      <!-- HUD Elements -->
      <div class="hud-element body-stat sci-panel">
        <div class="text-xs text-indigo-300 mb-1">GAME STATUS</div>
        <div class="text-xs">
          <span>SYSTEM</span>: <span id="system-status" class="text-green-400">STANDBY</span>
        </div>
        <div class="text-xs">
          <span>GAMES AVAILABLE</span>: <span class="text-yellow-400">5</span>
        </div>
      </div>
      <!-- Scan Line Animation -->
      <div class="body-scan-line"></div>
      <!-- Target Tracker (will be positioned in JS) -->
      <div id="body-tracker" class="tracker"></div>
      <!-- AR Labels (renamed to game names) -->
      <div id="head-label" class="ar-label ar-label-left">MEMORY TEST</div>
      <div id="torso-label" class="ar-label ar-label-right">PULSE TEST</div>
      <div id="arm-label" class="ar-label ar-label-left">REACTION TEST</div>
      <div id="leg-label" class="ar-label ar-label-right">BALANCE TEST</div>
      <div id="abdomen-label" class="ar-label ar-label-right">BMI CALCULATOR</div>
      <!-- Controls Guide -->
      <div id="controls-guide" class="sci-panel">
        <div class="text-xs text-indigo-300 mb-1 font-semibold">INTERFACE CONTROLS</div>
        <div class="grid grid-cols-2 gap-x-3 gap-y-1 text-xs">
          <span>ROTATE VIEW</span><span class="text-gray-300">Left Mouse / Drag</span>
          <span>ZOOM</span><span class="text-gray-300">Mouse Wheel</span>
          <span>PAN</span><span class="text-gray-300">Right Mouse / Drag</span>
          <span>RESET VIEW</span><span class="text-gray-300">Double Click</span>
          <span>SELECT GAME</span><span class="text-gray-300">Click Body Part</span>
        </div>
      </div>
    </div>
  </div>

  <!-- Audio Elements -->
  <audio id="sound-click" preload="auto">
    <source src="https://assets.mixkit.co/sfx/preview/mixkit-modern-technology-select-3124.mp3" type="audio/mpeg">
  </audio>
  <audio id="sound-hover" preload="auto">
    <source src="https://assets.mixkit.co/sfx/preview/mixkit-interface-hint-notification-911.mp3" type="audio/mpeg">
  </audio>
  <audio id="sound-scan" preload="auto">
    <source src="https://assets.mixkit.co/sfx/preview/mixkit-sci-fi-interface-zoom-890.mp3" type="audio/mpeg">
  </audio>

  <!-- React components -->
  <script type="text/babel">
    // Component to manage which game is shown
    const GameManager = () => {
      const [activeGame, setActiveGame] = React.useState(null);
      
      // Function to be exposed globally
      window.loadGame = (gameId) => {
        setActiveGame(gameId);
      };
      
      // Render the appropriate game component based on the active game
      const renderGame = () => {
        switch(activeGame) {
          case 'head': return <MemoryTest />;
          case 'chest': return <PulseTest />;
          case 'abdomen': return <BMICalculator />;
          case 'leftArm': 
          case 'rightArm': return <ReactionTest />;
          case 'leftLeg':
          case 'rightLeg': return <BalanceTest />;
          default: return <WelcomeScreen />;
        }
      };
      
      return (
        <div className="game-panel">
          {renderGame()}
        </div>
      );
    };

    // Welcome screen shown initially
    const WelcomeScreen = () => (
      <div className="sci-panel p-4 info-card show">
        <p className="text-gray-300 text-sm">
          Welcome to the <span className="sci-highlight">Human Anatomy Explorer Games</span>.
          Click on different body parts to access interactive learning games.
        </p>
        <p className="text-gray-300 text-sm mt-2">
          <strong>Available Games:</strong>
        </p>
        <ul className="text-gray-300 text-sm mt-1 space-y-1">
          <li>• <span className="text-indigo-300">Head</span> - Memory Test</li>
          <li>• <span className="text-indigo-300">Chest</span> - Pulse Test</li>
          <li>• <span className="text-indigo-300">Abdomen</span> - BMI Calculator</li>
          <li>• <span className="text-indigo-300">Arms</span> - Reaction Test</li>
          <li>• <span className="text-indigo-300">Legs</span> - Balance Test</li>
        </ul>
      </div>
    );

    // HEAD: Memory Test
    const MemoryTest = () => {
      const [gameState, setGameState] = React.useState('intro'); // intro, playing, success, failure
      const [sequence, setSequence] = React.useState([]);
      const [userSequence, setUserSequence] = React.useState([]);
      const [level, setLevel] = React.useState(1);
      
      // Colors for the memory game
      const colors = ['red', 'blue', 'green', 'yellow'];
      
      // Start a new game
      const startGame = () => {
        // Generate random sequence based on level (level + 2 items)
        const newSequence = Array.from({ length: level + 2 }, () => 
          colors[Math.floor(Math.random() * colors.length)]
        );
        setSequence(newSequence);
        setUserSequence([]);
        setGameState('playing');
      };
      
      // Handle user selection
      const handleColorClick = (color) => {
        const newUserSequence = [...userSequence, color];
        setUserSequence(newUserSequence);
        
        // Check if selection is correct
        const index = userSequence.length;
        if (color !== sequence[index]) {
          setGameState('failure');
          return;
        }
        
        // Check if sequence is complete
        if (newUserSequence.length === sequence.length) {
          setGameState('success');
          // Advance to next level after delay
          setTimeout(() => {
            setLevel(level + 1);
            setGameState('intro');
          }, 2000);
        }
      };
      
      // Reset the game
      const resetGame = () => {
        setLevel(1);
        setGameState('intro');
      };
      
      return (
        <div className="max-w-md mx-auto bg-gray-800 p-6 rounded-lg shadow-md">
          <h2 className="text-xl font-semibold mb-4 text-white">Memory Test</h2>
          
          {gameState === 'intro' && (
            <div>
              <p className="mb-4 text-gray-300">
                Remember the sequence of colors and repeat it. 
                Current level: {level} ({level + 2} colors to remember)
              </p>
              <button 
                onClick={startGame}
                className="w-full py-2 bg-blue-600 text-white rounded hover:bg-blue-500"
              >
                Start Test
              </button>
            </div>
          )}
          
          {gameState === 'playing' && (
            <div>
              <p className="mb-3 text-gray-300">Click the colors in the correct sequence:</p>
              <div className="grid grid-cols-2 gap-3 mb-4">
                {colors.map((color) => (
                  <button
                    key={color}
                    onClick={() => handleColorClick(color)}
                    className={`h-24 rounded-lg border-2 border-gray-700 capitalize font-bold ${
                      color === 'red' ? 'bg-red-500 text-white' :
                      color === 'blue' ? 'bg-blue-500 text-white' :
                      color === 'green' ? 'bg-green-500 text-white' :
                      'bg-yellow-500 text-white'
                    }`}
                  >
                    {color}
                  </button>
                ))}
              </div>
              <div className="flex justify-between items-center text-gray-300">
                <span>Progress: {userSequence.length}/{sequence.length}</span>
                <button 
                  onClick={resetGame}
                  className="text-sm px-3 py-1 bg-gray-700 rounded hover:bg-gray-600"
                >
                  Reset
                </button>
              </div>
            </div>
          )}
          
          {gameState === 'success' && (
            <div className="text-center py-6">
              <p className="text-green-400 text-xl mb-2">Great job!</p>
              <p className="text-gray-300">You completed level {level} successfully.</p>
              <p className="text-sm mt-3 text-gray-400">Advancing to level {level + 1}...</p>
            </div>
          )}
          
          {gameState === 'failure' && (
            <div className="text-center py-6">
              <p className="text-red-400 text-xl mb-2">Incorrect sequence!</p>
              <p className="text-gray-300">You reached level {level}.</p>
              <button 
                onClick={resetGame}
                className="mt-4 px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-500"
              >
                Try Again
              </button>
            </div>
          )}
        </div>
      );
    };

    // CHEST: Pulse Test
    const PulseTest = () => {
      const [heartRate, setHeartRate] = React.useState('');
      const [age, setAge] = React.useState('');
      const [result, setResult] = React.useState(null);
      
      const checkHeartRate = () => {
        const rate = parseInt(heartRate);
        const ageVal = parseInt(age);
        
        if (isNaN(rate) || isNaN(ageVal)) {
          setResult({
            status: 'error',
            message: 'Please enter valid numbers for heart rate and age.'
          });
          return;
        }
        
        // Simple heart rate evaluation based on age
        let status, message;
        
        if (ageVal < 18) {
          if (rate < 60) {
            status = 'warning';
            message = 'Your heart rate appears to be below the typical range for your age.';
          } else if (rate > 100) {
            status = 'warning';
            message = 'Your heart rate appears to be above the typical range for your age.';
          } else {
            status = 'good';
            message = 'Your heart rate appears to be within a normal range for your age.';
          }
        } else if (ageVal >= 18 && ageVal < 65) {
          if (rate < 60) {
            status = 'warning';
            message = 'Your resting heart rate is below typical adult range. This could be normal for athletes.';
          } else if (rate > 100) {
            status = 'warning';
            message = 'Your heart rate is elevated above the typical adult range.';
          } else {
            status = 'good';
            message = 'Your heart rate is within the normal adult range.';
          }
        } else {
          if (rate < 50) {
            status = 'warning';
            message = 'Your heart rate appears to be below the typical range for your age.';
          } else if (rate > 90) {
            status = 'warning';
            message = 'Your heart rate appears to be elevated for your age group.';
          } else {
            status = 'good';
            message = 'Your heart rate is within a normal range for your age.';
          }
        }
        
        setResult({ status, message, rate });
      };
      
      return (
        <div className="max-w-md mx-auto bg-gray-800 p-6 rounded-lg shadow-md">
          <h2 className="text-xl font-semibold mb-4 text-white">Pulse Rate Test</h2>
          
          <div className="mb-4">
            <label className="block text-gray-300 mb-2">Your age:</label>
            <input
              type="number"
              value={age}
              onChange={(e) => setAge(e.target.value)}
              placeholder="Enter your age"
              className="w-full p-2 border rounded bg-gray-700 text-white border-gray-600 focus:outline-none focus:ring-2 focus:ring-blue-400"
            />
          </div>
          
          <div className="mb-6">
            <label className="block text-gray-300 mb-2">Heart rate (BPM):</label>
            <input
              type="number"
              value={heartRate}
              onChange={(e) => setHeartRate(e.target.value)}
              placeholder="Enter beats per minute"
              className="w-full p-2 border rounded bg-gray-700 text-white border-gray-600 focus:outline-none focus:ring-2 focus:ring-blue-400"
            />
            <p className="text-sm text-gray-400 mt-1">
              How to measure: Find your pulse on your wrist or neck and count beats for 15 seconds, then multiply by 4.
            </p>
          </div>
          
          <button 
            onClick={checkHeartRate}
            className="w-full py-2 bg-blue-600 text-white rounded hover:bg-blue-500"
          >
            Check My Heart Rate
          </button>
          
          {result && (
            <div className={`mt-6 p-4 rounded-lg ${
              result.status === 'good' ? 'bg-green-900 border border-green-700' : 
              result.status === 'warning' ? 'bg-yellow-900 border border-yellow-700' :
              'bg-red-900 border border-red-700'
            }`}>
              <div className="flex items-center mb-2">
                <span className="text-2xl mr-2">
                  {result.status === 'good' ? '✅' : 
                  result.status === 'warning' ? '⚠️' : 
                  '❌'}
                </span>
                <h3 className="font-medium text-white">
                  {result.status === 'good' ? 'Normal Rate' : 
                  result.status === 'warning' ? 'Attention Recommended'
                    : 'Error'}
                </h3>
              </div>
              <p className={`${
                result.status === 'good' ? 'text-green-300' : 
                result.status === 'warning' ? 'text-yellow-300' :
                'text-red-300'
              }`}>
                {result.message}
              </p>
              <p className="mt-3 text-sm text-gray-400">
                <strong>Important:</strong> This is not a medical diagnosis. Consult a healthcare professional for proper evaluation.
              </p>
            </div>
          )}
        </div>
      );
    };

    // ABDOMEN: BMI Calculator
    const BMICalculator = () => {
      const [height, setHeight] = React.useState('');
      const [weight, setWeight] = React.useState('');
      const [unit, setUnit] = React.useState('metric'); // metric or imperial
      const [result, setResult] = React.useState(null);
      
      const calculateBMI = () => {
        let bmi, heightVal, weightVal;
        
        if (unit === 'metric') {
          // Metric: weight in kg, height in cm
          heightVal = parseFloat(height);
          weightVal = parseFloat(weight);
          
          if (isNaN(heightVal) || isNaN(weightVal) || heightVal <= 0 || weightVal <= 0) {
            setResult({ error: 'Please enter valid height and weight values' });
            return;
          }
          
          // Convert cm to meters and calculate BMI
          bmi = weightVal / Math.pow(heightVal / 100, 2);
        } else {
          // Imperial: weight in lbs, height in inches
          heightVal = parseFloat(height);
          weightVal = parseFloat(weight);
          
          if (isNaN(heightVal) || isNaN(weightVal) || heightVal <= 0 || weightVal <= 0) {
            setResult({ error: 'Please enter valid height and weight values' });
            return;
          }
          
          // Imperial BMI formula: (weight in pounds * 703) / (height in inches)²
          bmi = (weightVal * 703) / Math.pow(heightVal, 2);
        }
        
        // Round to one decimal place
        bmi = Math.round(bmi * 10) / 10;
        
        // Determine BMI category
        let category, color;
        if (bmi < 18.5) {
          category = 'Underweight';
          color = 'text-blue-400';
        } else if (bmi >= 18.5 && bmi < 25) {
          category = 'Normal weight';
          color = 'text-green-400';
        } else if (bmi >= 25 && bmi < 30) {
          category = 'Overweight';
          color = 'text-yellow-400';
        } else {
          category = 'Obesity';
          color = 'text-red-400';
        }
        
        setResult({ bmi, category, color });
      };
      
      return (
        <div className="max-w-md mx-auto bg-gray-800 p-6 rounded-lg shadow-md">
          <h2 className="text-xl font-semibold mb-4 text-white">BMI Calculator</h2>
          
          <div className="mb-4">
            <label className="block text-gray-300 mb-2">Unit System:</label>
            <div className="flex">
              <button 
                onClick={() => setUnit('metric')}
                className={`flex-1 py-2 ${unit === 'metric' ? 'bg-blue-600 text-white' : 'bg-gray-700 text-gray-300'} rounded-l`}
              >
                Metric
              </button>
              <button 
                onClick={() => setUnit('imperial')}
                className={`flex-1 py-2 ${unit === 'imperial' ? 'bg-blue-600 text-white' : 'bg-gray-700 text-gray-300'} rounded-r`}
              >
                Imperial
              </button>
            </div>
          </div>
          
          <div className="mb-4">
            <label className="block text-gray-300 mb-2">
              Height {unit === 'metric' ? '(cm)' : '(inches)'}:
            </label>
            <input
              type="number"
              value={height}
              onChange={(e) => setHeight(e.target.value)}
              placeholder={unit === 'metric' ? 'Enter height in cm' : 'Enter height in inches'}
              className="w-full p-2 border rounded bg-gray-700 text-white border-gray-600 focus:outline-none focus:ring-2 focus:ring-blue-400"
            />
          </div>
          
          <div className="mb-6">
            <label className="block text-gray-300 mb-2">
              Weight {unit === 'metric' ? '(kg)' : '(lbs)'}:
            </label>
            <input
              type="number"
              value={weight}
              onChange={(e) => setWeight(e.target.value)}
              placeholder={unit === 'metric' ? 'Enter weight in kg' : 'Enter weight in lbs'}
              className="w-full p-2 border rounded bg-gray-700 text-white border-gray-600 focus:outline-none focus:ring-2 focus:ring-blue-400"
            />
          </div>
          
          <button 
            onClick={calculateBMI}
            className="w-full py-2 bg-blue-600 text-white rounded hover:bg-blue-500"
          >
            Calculate BMI
          </button>
          
          {result && !result.error && (
            <div className="mt-6 p-4 bg-gray-900 rounded-lg border border-gray-700">
              <h3 className="font-medium text-lg mb-3 text-white">Your Results</h3>
              <div className="flex justify-between mb-2 text-gray-300">
                <span>BMI Value:</span>
                <span className="font-semibold text-white">{result.bmi}</span>
              </div>
              <div className="flex justify-between text-gray-300">
                <span>Category:</span>
                <span className={`font-semibold ${result.color}`}>{result.category}</span>
              </div>
              <div className="mt-4 pt-4 border-t border-gray-700">
                <h4 className="font-medium mb-2 text-gray-300">BMI Categories:</h4>
                <ul className="text-sm space-y-1 text-gray-400">
                  <li><span className="text-blue-400 font-medium">Below 18.5:</span> Underweight</li>
                  <li><span className="text-green-400 font-medium">18.5 - 24.9:</span> Normal weight</li>
                  <li><span className="text-yellow-400 font-medium">25 - 29.9:</span> Overweight</li>
                  <li><span className="text-red-400 font-medium">30 and above:</span> Obesity</li>
                </ul>
              </div>
            </div>
          )}
          
          {result && result.error && (
            <div className="mt-4 p-3 bg-red-900 text-red-300 rounded border border-red-700">
              {result.error}
            </div>
          )}
        </div>
      );
    };

    // HANDS/ARMS: Reaction Test
    const ReactionTest = () => {
      const [state, setState] = React.useState('ready'); // ready, waiting, click, results
      const [startTime, setStartTime] = React.useState(null);
      const [reactionTime, setReactionTime] = React.useState(null);
      const [results, setResults] = React.useState([]);
      
      // Start the test
      const startTest = () => {
        setState('waiting');
        
        // Random delay between 1-5 seconds
        const delay = 1000 + Math.random() * 4000;
        
        setTimeout(() => {
          setStartTime(Date.now());
          setState('click');
        }, delay);
      };
      
      // Handle user click
      const handleClick = () => {
        if (state === 'waiting') {
          // Clicked too early
          setState('ready');
          alert('Too early! Wait for the green color.');
        } else if (state === 'click') {
          // Measure reaction time
          const endTime = Date.now();
          const time = endTime - startTime;
          setReactionTime(time);
          
          // Add to results history (keep last 5)
          const newResults = [time, ...results].slice(0, 5);
          setResults(newResults);
          
          setState('results');
        }
      };
      
      // Get feedback based on reaction time
      const getFeedback = (time) => {
        if (time < 200) return { text: 'Incredible!', color: 'text-purple-400' };
        if (time < 250) return { text: 'Excellent!', color: 'text-indigo-400' };
        if (time < 300) return { text: 'Very Good!', color: 'text-blue-400' };
        if (time < 350) return { text: 'Good', color: 'text-green-400' };
        if (time < 400) return { text: 'Average', color: 'text-yellow-400' };
        return { text: 'Keep practicing', color: 'text-red-400' };
      };
      
      // Calculate average reaction time
      const getAverage = () => {
        if (results.length === 0) return null;
        const sum = results.reduce((a, b) => a + b, 0);
        return Math.round(sum / results.length);
      };
      
      // Get background color based on state
      const getBackgroundColor = () => {
        if (state === 'ready') return 'bg-blue-900 hover:bg-blue-800';
        if (state === 'waiting') return 'bg-red-700';
        if (state === 'click') return 'bg-green-700';
        return 'bg-gray-800';
      };
      
      return (
        <div className="max-w-md mx-auto bg-gray-800 p-6 rounded-lg shadow-md">
          <h2 className="text-xl font-semibold mb-4 text-white">Reaction Time Test</h2>
          
          <div 
            onClick={state === 'ready' ? startTest : handleClick}
            className={`w-full h-64 rounded-lg flex items-center justify-center cursor-pointer transition-colors ${getBackgroundColor()}`}
          >
            <div className="text-center p-4">
              {state === 'ready' && (
                <div>
                  <p className="font-medium mb-2 text-white">Click to start the test</p>
                  <p className="text-sm text-gray-300">Wait for the green color, then click as fast as you can!</p>
                </div>
              )}
              
              {state === 'waiting' && (
                <p className="font-medium text-white">Wait for green...</p>
              )}
              
              {state === 'click' && (
                <p className="font-medium text-white">CLICK NOW!</p>
              )}
              
              {state === 'results' && (
                <div>
                  <p className="text-2xl font-bold mb-1 text-white">{reactionTime} ms</p>
                  {reactionTime && (
                    <p className={`font-medium ${getFeedback(reactionTime).color}`}>
                      {getFeedback(reactionTime).text}
                    </p>
                  )}
                  <button 
                    onClick={(e) => {
                      e.stopPropagation();
                      setState('ready');
                    }}
                    className="mt-3 px-4 py-1 bg-blue-600 text-white text-sm rounded hover:bg-blue-500"
                  >
                    Try Again
                  </button>
                </div>
              )}
            </div>
          </div>
          
          {results.length > 0 && (
            <div className="mt-5">
              <h3 className="font-medium mb-2 text-gray-300">Your history:</h3>
              <div className="flex flex-wrap gap-2">
                {results.map((time, index) => (
                  <div key={index} className="px-3 py-1 bg-gray-700 rounded text-sm text-gray-300">
                    {time} ms
                  </div>
                ))}
              </div>
              {results.length > 1 && (
                <p className="mt-3 text-sm text-gray-300">
                  Average: <span className="font-medium text-white">{getAverage()} ms</span>
                </p>
              )}
            </div>
          )}
        </div>
      );
    };

    // LEGS: Balance Test
    const BalanceTest = () => {
      const [timerRunning, setTimerRunning] = React.useState(false);
      const [startTime, setStartTime] = React.useState(null);
      const [elapsedTime, setElapsedTime] = React.useState(0);
      const [bestTime, setBestTime] = React.useState(0);
      const [leg, setLeg] = React.useState('right');
      const [feedbackVisible, setFeedbackVisible] = React.useState(false);
      const [intervalId, setIntervalId] = React.useState(null);
      
      // Start the timer
      const startTimer = () => {
        setTimerRunning(true);
        setStartTime(Date.now());
        setElapsedTime(0);
        setFeedbackVisible(false);
        
        // Update timer every 100ms
        const newIntervalId = setInterval(() => {
          setElapsedTime((Date.now() - startTime) / 1000);
        }, 100);
        
        setIntervalId(newIntervalId);
      };
      
      // Stop the timer
      const stopTimer = () => {
        setTimerRunning(false);
        
        // Clear the interval
        if (intervalId) {
          clearInterval(intervalId);
          setIntervalId(null);
        }
        
        // Update best time if current time is better
        if (elapsedTime > bestTime) {
          setBestTime(elapsedTime);
        }
        
        setFeedbackVisible(true);
      };
      
      // Clean up interval on unmount
      React.useEffect(() => {
        return () => {
          if (intervalId) {
            clearInterval(intervalId);
          }
        };
      }, [intervalId]);
      
      // Get feedback based on balance time
      const getFeedback = () => {
        // Simplified feedback thresholds
        if (elapsedTime < 10) {
          return {
            text: 'Needs improvement. Try to build up your balance gradually.',
            color: 'text-red-400'
          };
        } else if (elapsedTime < 20) {
          return {
            text: 'Fair balance. Regular practice will help improve.',
            color: 'text-yellow-400'
          };
        } else if (elapsedTime < 30) {
          return {
            text: 'Good balance! You\'re on the right track.',
            color: 'text-green-400'
          };
        } else {
          return {
            text: 'Excellent balance! Keep maintaining this ability.',
            color: 'text-blue-400'
          };
        }
      };
      
      return (
        <div className="max-w-md mx-auto bg-gray-800 p-6 rounded-lg shadow-md">
          <h2 className="text-xl font-semibold mb-4 text-white">Balance Test</h2>
          
          <div className="mb-4 flex justify-center">
            <div className="inline-flex rounded-md shadow-sm" role="group">
              <button
                type="button"
                onClick={() => setLeg('right')}
                className={`px-4 py-2 text-sm font-medium rounded-l-lg ${
                  leg === 'right' 
                    ? 'bg-blue-600 text-white' 
                    : 'bg-gray-700 text-gray-300 hover:bg-gray-600'
                }`}
              >
                Right Leg
              </button>
              <button
                type="button"
                onClick={() => setLeg('left')}
                className={`px-4 py-2 text-sm font-medium rounded-r-lg ${
                  leg === 'left' 
                    ? 'bg-blue-600 text-white' 
                    : 'bg-gray-700 text-gray-300 hover:bg-gray-600'
                }`}
              >
                Left Leg
              </button>
            </div>
          </div>
          
          <div id="timer-container" className="text-center py-4">
            <div className="text-5xl font-bold mb-4 text-white">{elapsedTime.toFixed(2)}</div>
            <p className="text-sm text-gray-300 mb-4">
              Stand on your {leg} leg in a safe area. Press start when ready, and stop when you lose balance.
            </p>
            
            {!timerRunning ? (
              <button 
                onClick={startTimer}
                className="w-full py-3 bg-green-600 text-white rounded-lg text-lg hover:bg-green-500"
              >
                Start
              </button>
            ) : (
              <button 
                onClick={stopTimer}
                className="w-full py-3 bg-red-600 text-white rounded-lg text-lg hover:bg-red-500"
              >
                Stop
              </button>
            )}
            
            {bestTime > 0 && (
              <p className="mt-3 text-sm font-medium text-gray-300">
                Best time: <span className="text-white">{bestTime.toFixed(2)}</span> seconds
              </p>
            )}
          </div>
          
          {feedbackVisible && (
            <div className="mt-4 p-4 rounded-lg bg-gray-900 border border-gray-700">
              <h3 className="font-medium mb-1 text-white">Your Results</h3>
              <p className={getFeedback().color}>{getFeedback().text}</p>
              <div className="mt-4 text-sm text-gray-400">
                <p className="mb-1"><strong>Balance Benchmarks:</strong></p>
                <ul className="list-disc list-inside space-y-1">
                  <li><span className="text-red-400 font-medium">Less than 10 seconds:</span> Needs improvement</li>
                  <li><span className="text-yellow-400 font-medium">10-20 seconds:</span> Fair</li>
                  <li><span className="text-green-400 font-medium">20-30 seconds:</span> Good</li>
                  <li><span className="text-blue-400 font-medium">More than 30 seconds:</span> Excellent</li>
                </ul>
                <p className="mt-3">Try again with your other leg to compare balance.</p>
              </div>
            </div>
          )}
        </div>
      );
    };

    // Render the main GameManager component to the DOM
    ReactDOM.render(
      <GameManager />,
      document.getElementById('game-container')
    );
  </script>

  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.163.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.163.0/examples/jsm/"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import { OutlinePass } from 'three/addons/postprocessing/OutlinePass.js';

    // --- Global Variables ---
    let scene, camera, renderer, controls, composer;
    let raycaster, mouse;
    let model;
    let bloomPass, outlinePass;
    let selectedPart = null;
    let initialCameraPosition = new THREE.Vector3();
    let initialControlsTarget = new THREE.Vector3();
    let arLabels = {};
    let tracker = document.getElementById('body-tracker');
    let audioEnabled = true;

    // DOM elements
    const canvasContainer = document.getElementById('canvas-container');
    const infoContent = document.getElementById('info-content');
    const loadingOverlay = document.getElementById('loading-overlay');
    const progressBar = document.getElementById('progress-bar');
    const loadingText = document.getElementById('loading-text');
    const panelToggle = document.getElementById('panel-toggle');
    const infoPanel = document.getElementById('info-panel');
    const systemStatus = document.getElementById('system-status');

    // Audio elements
    const soundClick = document.getElementById('sound-click');
    const soundHover = document.getElementById('sound-hover');
    const soundScan = document.getElementById('sound-scan');

    // Detailed information for each body part with improved zone coordinates
    const bodyPartsData = {
      head: {
        name: "Memory Test",  // Renamed from "Head"
        system: "Brain Training",  // Renamed from "Nervous System"
        description: "Test your short-term memory with a sequence recall game.",
        zone: new THREE.Box3(
          new THREE.Vector3(-0.5, 2.6, -0.5),
          new THREE.Vector3(0.5, 3.5, 0.5)
        )
      },
      chest: {
        name: "Pulse Test",  // Renamed from "Chest/Torso"
        system: "Heart Health",  // Renamed from "Respiratory & Cardiovascular Systems"
        description: "Check if your heart rate is within a healthy range.",
        zone: new THREE.Box3(
          new THREE.Vector3(-0.8, 1.5, -0.5),
          new THREE.Vector3(0.8, 2.6, 0.5)
        )
      },
      abdomen: {
        name: "BMI Calculator",  // Renamed from "Abdomen"
        system: "Body Composition",  // Renamed from "Digestive & Urinary Systems"
        description: "Calculate your Body Mass Index based on height and weight.",
        zone: new THREE.Box3(
          new THREE.Vector3(-0.4, 1.0, -0.3),
          new THREE.Vector3(0.4, 1.8, 0.3)
        )
      },
      leftArm: {
        name: "Reaction Test",  // Renamed from "Left Arm"
        system: "Reflex Training",  // Renamed from "Musculoskeletal System"
        description: "Test your reaction time with a simple click game.",
        zone: new THREE.Box3(
          new THREE.Vector3(-1.5, 1.2, -0.6),
          new THREE.Vector3(-0.5, 2.6, 0.6)
        )
      },
      rightArm: {
        name: "Reaction Test",  // Renamed from "Right Arm"
        system: "Reflex Training",  // Renamed from "Musculoskeletal System"
        description: "Test your reaction time with a simple click game.",
        zone: new THREE.Box3(
          new THREE.Vector3(0.5, 1.2, -0.6),
          new THREE.Vector3(1.5, 2.6, 0.6)
        )
      },
      leftLeg: {
        name: "Balance Test",  // Renamed from "Left Leg"
        system: "Stability Training",  // Renamed from "Musculoskeletal System"
        description: "Test your balance by standing on one leg.",
        zone: new THREE.Box3(
          new THREE.Vector3(-0.6, -0.2, -0.5),
          new THREE.Vector3(-0.1, 1.0, 0.5)
        )
      },
      rightLeg: {
        name: "Balance Test",  // Renamed from "Right Leg"
        system: "Stability Training",  // Renamed from "Musculoskeletal System"
        description: "Test your balance by standing on one leg.",
        zone: new THREE.Box3(
          new THREE.Vector3(0.1, -0.2, -0.5),
          new THREE.Vector3(0.6, 1.0, 0.5)
        )
      }
    };

    // --- Initialization ---
    function init() {
      initSceneAndCamera();
      setupRenderer();
      setupLighting();
      setupPostProcessing();
      setupControls();
      setupRaycaster();
      setupARElements();
      loadEnvironmentMap();
      loadModel();
      setupEventListeners();
      animate();
    }

    // --- Setup Scene and Camera ---
    function initSceneAndCamera() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x030712);
      scene.fog = new THREE.FogExp2(0x030712, 0.005);
      camera = new THREE.PerspectiveCamera(60, canvasContainer.clientWidth / canvasContainer.clientHeight, 0.1, 1000);
      camera.position.set(0, 1.2, 5);
    }

    // --- Setup Renderer ---
    function setupRenderer() {
      renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.setSize(canvasContainer.clientWidth, canvasContainer.clientHeight);
      renderer.outputEncoding = THREE.sRGBEncoding;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 1.2;
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      canvasContainer.appendChild(renderer.domElement);
    }

    // --- Setup Lighting ---
    function setupLighting() {
      const ambientLight = new THREE.AmbientLight(0x303050, 0.5);
      scene.add(ambientLight);
      const mainLight = new THREE.DirectionalLight(0x9090ff, 1.0);
      mainLight.position.set(5, 10, 7.5);
      mainLight.castShadow = true;
      mainLight.shadow.mapSize.width = 1024;
      mainLight.shadow.mapSize.height = 1024;
      scene.add(mainLight);
      const fillLight = new THREE.DirectionalLight(0x3040c0, 0.5);
      fillLight.position.set(-5, 0, -7.5);
      scene.add(fillLight);
      const pointLight1 = new THREE.PointLight(0x3060ff, 1, 10);
      pointLight1.position.set(3, 1, 3);
      scene.add(pointLight1);
      const pointLight2 = new THREE.PointLight(0x60ffff, 1, 10);
      pointLight2.position.set(-3, 1, -3);
      scene.add(pointLight2);
    }

    // --- Setup Post-Processing Effects ---
    function setupPostProcessing() {
      composer = new EffectComposer(renderer);
      const renderPass = new RenderPass(scene, camera);
      composer.addPass(renderPass);
      bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.2, 0.2, 0.9);
      composer.addPass(bloomPass);
      outlinePass = new OutlinePass(new THREE.Vector2(window.innerWidth, window.innerHeight), scene, camera);
      outlinePass.edgeStrength = 3.0;
      outlinePass.edgeGlow = 1.0;
      outlinePass.edgeThickness = 1.5;
      outlinePass.pulsePeriod = 2;
      outlinePass.visibleEdgeColor.set(0x4F46E5);
      outlinePass.hiddenEdgeColor.set(0x4F46E5);
      composer.addPass(outlinePass);
    }

    // --- Setup Controls ---
    function setupControls() {
      controls = new OrbitControls(camera, renderer.domElement);
      controls.target.set(0, 1.0, 0);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.screenSpacePanning = true;
      controls.minDistance = 1;
      controls.maxDistance = 20;
      controls.autoRotate = false;
      controls.autoRotateSpeed = 0.5;
      controls.update();
    }

    // --- Setup Raycaster ---
    function setupRaycaster() {
      raycaster = new THREE.Raycaster();
      mouse = new THREE.Vector2();
    }

    // --- Setup AR Elements ---
    function setupARElements() {
      arLabels = {
        head: document.getElementById('head-label'),
        torso: document.getElementById('torso-label'),
        arm: document.getElementById('arm-label'),
        leg: document.getElementById('leg-label'),
        abdomen: document.getElementById('abdomen-label')
      };
    }

    // --- Load Environment Map for Reflections ---
    function loadEnvironmentMap() {
      new RGBELoader()
        .setPath('https://dl.polyhaven.org/file/ph-assets/HDRIs/hdr/1k/')
        .load('royal_esplanade_1k.hdr', function(texture) {
          texture.mapping = THREE.EquirectangularReflectionMapping;
          scene.environment = texture;
        });
    }

    // --- Load 3D Model ---
    function loadModel() {
      const loader = new GLTFLoader();
      const modelUrl = './human_body.glb';
      progressBar.style.width = '5%';
      loadingText.textContent = 'Initializing model loader...';
      loader.load(
        modelUrl,
        function (gltf) {
          model = gltf.scene;
          optimizeAndCenterModel(model);
          applySciFiMaterial(model);
          scene.add(model);
          updateControlsForModel();
          completeLoading();
        },
        function (xhr) {
          const percentLoaded = Math.round((xhr.loaded / xhr.total) * 100);
          progressBar.style.width = percentLoaded + '%';
          loadingText.textContent = `Loading 3D model... ${percentLoaded}%`;
          if (percentLoaded === 100) {
            loadingText.textContent = 'Processing geometry...';
            setTimeout(() => {
              loadingText.textContent = 'Applying materials...';
              setTimeout(() => {
                loadingText.textContent = 'Finalizing render...';
              }, 500);
            }, 500);
          }
        },
        function (error) {
          loadingOverlay.innerHTML = `
            <div class="text-center p-6">
              <h2 class="text-2xl font-bold text-red-500 mb-4">Error Loading Model</h2>
              <p class="text-gray-300 mb-4">We encountered a problem while loading the 3D model.</p>
              <p class="text-sm text-gray-400 mb-6">${error.message || 'Unknown error'}</p>
              <button onclick="location.reload()" class="px-4 py-2 bg-indigo-600 hover:bg-indigo-700 text-white rounded-md">
                Try Again
              </button>
            </div>
          `;
        }
      );
    }

    // --- Optimize and Center Model with improved zone handling ---
    function optimizeAndCenterModel(model) {
      const box = new THREE.Box3().setFromObject(model);
      const center = box.getCenter(new THREE.Vector3());
      const size = box.getSize(new THREE.Vector3());
      const maxDim = Math.max(size.x, size.y, size.z);
      const desiredHeight = 3.0;
      const scale = desiredHeight / maxDim;
      
      model.scale.set(scale, scale, scale);
      box.setFromObject(model);
      box.getCenter(center);
      model.position.sub(center);
      model.position.y += box.max.y - center.y;
      
      // Store the model's final position and scale
      model.userData.finalScale = scale;
      model.userData.finalPosition = model.position.clone();
      
      console.log('Model scaled and centered. Scale:', scale, 'Position:', model.position);
      console.log('Model bounding box:', box.min, box.max);
      
      // No need to update zones - we've manually defined them to match the model
      // Just apply the model position offset to all zones
      Object.keys(bodyPartsData).forEach(part => {
        const zone = bodyPartsData[part].zone;
        zone.translate(model.position);
      });
    }

    // --- Add visual debug box for zones ---
    function addDebugBox(partId, box) {
      const size = new THREE.Vector3();
      box.getSize(size);
      
      const center = new THREE.Vector3();
      box.getCenter(center);
      
      // Create different colors for different body parts
      let color = 0xff0000; // Default red
      if (partId.includes('Arm')) {
        color = 0x00ff00; // Green for arms
      } else if (partId.includes('Leg')) {
        color = 0x0000ff; // Blue for legs
      } else if (partId === 'head') {
        color = 0xffff00; // Yellow for head
      } else if (partId === 'abdomen') {
        color = 0xff00ff; // Magenta for abdomen
      }
      
      const geometry = new THREE.BoxGeometry(size.x, size.y, size.z);
      const material = new THREE.MeshBasicMaterial({
        color: color,
        wireframe: true,
        transparent: true,
        opacity: 0.5
      });
      
      const debugBox = new THREE.Mesh(geometry, material);
      debugBox.position.copy(center);
      debugBox.name = 'debug_' + partId;
      scene.add(debugBox);
      
      console.log(`Added debug box for ${partId} at position ${center.x}, ${center.y}, ${center.z}`);
    }

    // --- Apply Sci-Fi Material Effect ---
    function applySciFiMaterial(model) {
      model.traverse((node) => {
        if (node.isMesh) {
          node.castShadow = true;
          node.receiveShadow = true;
          const material = node.material.clone();
          material.metalness = 0.3;
          material.roughness = 0.4;
          material.envMapIntensity = 1.0;
          if (material.color) {
            material.color.lerp(new THREE.Color(0x4060ff), 0.2);
          }
          node.material = material;
        }
      });
    }

    // --- Update Controls For Model ---
    function updateControlsForModel() {
      controls.target.set(model.position.x, model.position.y + 1.0, model.position.z);
      controls.update();
      initialCameraPosition.copy(camera.position);
      initialControlsTarget.copy(controls.target);
    }

    // --- Complete Loading Process ---
    function completeLoading() {
      setTimeout(startScanAnimation, 1000);
      loadingOverlay.style.transition = 'opacity 1s';
      loadingOverlay.style.opacity = '0';
      setTimeout(() => {
        loadingOverlay.style.display = 'none';
      }, 1000);
      updateSystemStatus('SCANNING', 'green');
      showWelcomeInfo();
    }

    // --- Start Scan Animation ---
    function startScanAnimation() {
      if (audioEnabled) {
        soundScan.volume = 0.3;
        soundScan.play().catch(e => {
          console.warn("Auto-play prevented:", e);
          audioEnabled = false;
        });
      }
      controls.autoRotate = true;
      setTimeout(() => { controls.autoRotate = false; }, 5000);
      setTimeout(() => showLabel('head'), 500);
      setTimeout(() => showLabel('torso'), 1000);
      setTimeout(() => showLabel('arm'), 1500);
      setTimeout(() => showLabel('leg'), 2000);
      setTimeout(() => showLabel('abdomen'), 1300);
      setTimeout(() => { updateSystemStatus('READY', 'green'); }, 3000);
    }

    // --- Show AR Label ---
    function showLabel(label) {
      if (arLabels[label]) {
        arLabels[label].style.opacity = '1';
      }
    }

    // --- Update System Status ---
    function updateSystemStatus(status, color) {
      systemStatus.textContent = status;
      systemStatus.className = '';
      if (color === 'green') {
        systemStatus.classList.add('text-green-400');
      } else if (color === 'yellow') {
        systemStatus.classList.add('text-yellow-400');
      } else if (color === 'red') {
        systemStatus.classList.add('text-red-400');
      }
    }

    // --- Show Welcome Info ---
    function showWelcomeInfo() {
      // This is now handled by React in the GameManager component
      updateSystemStatus('READY', 'green');
    }

    // --- Setup Event Listeners ---
    function setupEventListeners() {
      window.addEventListener('resize', onWindowResize);
      canvasContainer.addEventListener('click', onClick);
      canvasContainer.addEventListener('dblclick', onDoubleClick);
      canvasContainer.addEventListener('mousemove', onMouseMove);
      if (panelToggle) {
        panelToggle.addEventListener('click', () => {
          infoPanel.classList.toggle('collapsed');
        });
      }
      
      // Add keyboard listener for zone visualization toggle
      document.addEventListener('keydown', function(event) {
        if (event.key === 'z' || event.key === 'Z') {
          let zonesVisible = scene.children.some(child => 
            child.name && child.name.startsWith('debug_')
          );
          
          if (zonesVisible) {
            // Hide zones
            scene.children.forEach(child => {
              if (child.name && child.name.startsWith('debug_')) {
                scene.remove(child);
              }
            });
            console.log('Zone visualization disabled');
          } else {
            // Show zones
            showAllZones();
          }
        }
      });
    }

    // --- Visualization of all zones for debugging ---
    function showAllZones() {
      // First clear any existing debug boxes
      scene.children.forEach(child => {
        if (child.name && child.name.startsWith('debug_')) {
          scene.remove(child);
        }
      });
      
      // Create a debug box for each body part zone
      Object.keys(bodyPartsData).forEach(part => {
        const zone = bodyPartsData[part].zone;
        addDebugBox(part, zone);
      });
      
      console.log('Zone visualization enabled');
    }

    // --- Handle Window Resize ---
    function onWindowResize() {
      if (!renderer || !camera || !canvasContainer) return;
      camera.aspect = canvasContainer.clientWidth / canvasContainer.clientHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(canvasContainer.clientWidth, canvasContainer.clientHeight);
      composer.setSize(canvasContainer.clientWidth, canvasContainer.clientHeight);
      updateARLabelsPositions();
    }

    // --- Handle Double Click (Reset View) ---
    function onDoubleClick() {
      if (!controls || !initialCameraPosition || !initialControlsTarget) return;
      if (audioEnabled) {
        soundClick.volume = 0.2;
        soundClick.play().catch(e => console.warn("Audio play prevented:", e));
      }
      camera.position.copy(initialCameraPosition);
      controls.target.copy(initialControlsTarget);
      controls.update();
      updateSystemStatus('VIEW RESET', 'yellow');
      setTimeout(() => updateSystemStatus('READY', 'green'), 2000);
    }

    // --- Handle Mouse Move ---
    function onMouseMove(event) {
      if (!model) return;
      const rect = renderer.domElement.getBoundingClientRect();
      mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObject(model, true);
      if (intersects.length > 0) {
        document.body.style.cursor = 'pointer';
        const clickPoint = intersects[0].point;
        const hoveredPart = getBodyPartAtPoint(clickPoint);
        if (hoveredPart && hoveredPart !== selectedPart) {
          updateTrackerPosition(clickPoint);
          if (audioEnabled && Math.random() > 0.95) {
            soundHover.volume = 0.1;
            soundHover.play().catch(e => console.warn("Audio play prevented:", e));
          }
        }
      } else {
        document.body.style.cursor = 'default';
        hideTracker();
      }
    }

    // --- Update Tracker Position ---
    function updateTrackerPosition(position) {
      if (!tracker) return;
      const vector = new THREE.Vector3(position.x, position.y, position.z);
      vector.project(camera);
      const x = (vector.x * 0.5 + 0.5) * canvasContainer.clientWidth;
      const y = (-(vector.y * 0.5) + 0.5) * canvasContainer.clientHeight;
      tracker.style.left = x + 'px';
      tracker.style.top = y + 'px';
      tracker.style.opacity = '1';
    }

    // --- Hide Tracker ---
    function hideTracker() {
      if (tracker) {
        tracker.style.opacity = '0';
      }
    }

    // --- Improved Click Handler - Now loads games ---
    function onClick(event) {
      if (!model) return;
      
      const rect = renderer.domElement.getBoundingClientRect();
      mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
      
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObject(model, true);
      
      if (intersects.length > 0) {
        const clickPoint = intersects[0].point;
        console.log('Click Point:', clickPoint);
        
        // Try to get body part using the improved function
        const partId = getBodyPartAtPoint(clickPoint);
        
        if (partId) {
          selectBodyPart(partId, clickPoint);
          
          // Load the appropriate game using the window.loadGame function exposed by React
          if (window.loadGame) {
            window.loadGame(partId);
          }
        } else {
          console.log('Clicked on model but no part identified');
        }
      } else {
        clearBodyPartSelection();
      }
    }

    // --- Get Body Part At Point with EXTREMELY aggressive arm and abdomen detection ---
    function getBodyPartAtPoint(point) {
      // Debug: Log the point coordinates for troubleshooting
      console.log('Checking point:', point);
      
      const y = point.y;
      const x = point.x;
      
      // EXTREMELY AGGRESSIVE ARM DETECTION
      // This will override the chest detection when x is far enough from center
      if (y > 1.2 && y < 2.6) {  // FIXED: Raised lower bound from 0.5 to 1.2 to match arm zone
        // Far left = left arm (no matter what other detections say)
        if (x < -0.5) {
          console.log('Aggressive arm detection: leftArm');
          return 'leftArm';
        }
        
        // Far right = right arm (no matter what other detections say)
        if (x > 0.5) {
          console.log('Aggressive arm detection: rightArm');
          return 'rightArm';
        }
      }
      
      // Special case for abdomen to make it more central - with CORRECTED height
      if (Math.abs(x) < 0.4 && y > 1.0 && y < 1.8) {  // Fixed height
        console.log('Direct abdomen detection');
        return 'abdomen';
      }
      
      // Standard detection for all parts
      const tolerance = 0.3;
      for (const partId in bodyPartsData) {
        const zone = bodyPartsData[partId].zone.clone();
        zone.expandByScalar(tolerance);
        
        if (zone.containsPoint(point)) {
          console.log('Direct hit on zone:', partId);
          return partId;
        }
      }
      
      // Find closest part if no direct hit
      let closestPart = null;
      let minDistance = Infinity;
      
      for (const partId in bodyPartsData) {
        const zoneCenter = new THREE.Vector3();
        bodyPartsData[partId].zone.getCenter(zoneCenter);
        
        const distance = point.distanceTo(zoneCenter);
        console.log(`Distance to ${partId}: ${distance.toFixed(3)}`);
        
        if (distance < minDistance) {
          minDistance = distance;
          closestPart = partId;
        }
      }
      
      // Use closest part if it's within a reasonable distance
      if (minDistance < 1.5) {
        console.log(`Using closest part: ${closestPart}, distance: ${minDistance.toFixed(3)}`);
        return closestPart;
      }
      
      console.log('No body part found at point');
      return null;
    }

    // --- Select Body Part with improved highlighting ---
    function selectBodyPart(partId, clickPoint) {
      if (audioEnabled) {
        soundClick.volume = 0.3;
        soundClick.currentTime = 0;
        soundClick.play().catch(e => console.warn("Audio play prevented:", e));
      }
      if (selectedPart === partId) return;
      selectedPart = partId;
      updateSystemStatus('LOADING GAME', 'yellow');
      
      // Try to select meshes that are within the zone of the selected part
      const selectedObjects = [];
      
      // For arm parts, use special handling
      if (partId === 'leftArm' || partId === 'rightArm') {
        // Determine which side to check
        const isLeft = partId === 'leftArm';
        const xThreshold = isLeft ? 0 : 0; // Use 0 as the dividing line
        
        // Check all meshes 
        model.traverse((object) => {
          if (object.isMesh) {
            const meshPosition = new THREE.Vector3();
            object.getWorldPosition(meshPosition);
            
            // For arms, check if the mesh is on the correct side (left or right)
            // and in the appropriate height range
            if ((isLeft && meshPosition.x < xThreshold) || (!isLeft && meshPosition.x > xThreshold)) {
              if (meshPosition.y > 1.2 && meshPosition.y < 2.7) { // FIXED: Updated height range for arms
                selectedObjects.push(object);
              }
            }
          }
        });
      } 
      // Special case for abdomen to ensure correct selection - CORRECTED height
      else if (partId === 'abdomen') {
        model.traverse((object) => {
          if (object.isMesh) {
            const meshPosition = new THREE.Vector3();
            object.getWorldPosition(meshPosition);
            
            // For abdomen, check if the mesh is in the central area
            if (Math.abs(meshPosition.x) < 0.5 && meshPosition.y > 1.0 && meshPosition.y < 1.8) {  // Fixed height
              selectedObjects.push(object);
            }
          }
        });
      }
      // Special case for legs with updated height range
      else if (partId === 'leftLeg' || partId === 'rightLeg') {
        // Determine which side to check
        const isLeft = partId === 'leftLeg';
        const xThreshold = isLeft ? 0 : 0; // Use 0 as the dividing line
        
        model.traverse((object) => {
          if (object.isMesh) {
            const meshPosition = new THREE.Vector3();
            object.getWorldPosition(meshPosition);
            
            // For legs, check if the mesh is on the correct side (left or right)
            // and in the appropriate height range
            if ((isLeft && meshPosition.x < xThreshold) || (!isLeft && meshPosition.x > xThreshold)) {
              if (meshPosition.y > -0.2 && meshPosition.y < 1.0) { // Updated height range for legs
                selectedObjects.push(object);
              }
            }
          }
        });
      }
      else {
        // For non-arm/non-leg parts, use the standard zone-based approach
        model.traverse((object) => {
          if (object.isMesh) {
            const meshPosition = new THREE.Vector3();
            object.getWorldPosition(meshPosition);
            
            // Use extended zone for selection to be more inclusive
            const extendedZone = bodyPartsData[partId].zone.clone().expandByScalar(0.3);
            if (extendedZone.containsPoint(meshPosition)) {
              selectedObjects.push(object);
            }
          }
        });
      }
      
      // If no meshes were selected, try alternative methods
      if (selectedObjects.length === 0) {
        console.log('No meshes in zone, selecting by object names for', partId);
        
        // First try: select by part name in mesh name
        model.traverse((object) => {
          if (object.isMesh) {
            const meshName = object.name.toLowerCase();
            const partName = bodyPartsData[partId].name.toLowerCase();
            if (
              meshName.includes(partId) || 
              meshName.includes(partName) ||
              (partId === 'head' && (meshName.includes('head') || meshName.includes('skull') || meshName.includes('face'))) ||
              (partId === 'chest' && (meshName.includes('chest') || meshName.includes('torso') || meshName.includes('rib'))) ||
              (partId === 'abdomen' && (meshName.includes('abdomen') || meshName.includes('stomach') || meshName.includes('waist'))) ||
              (partId.includes('arm') && (meshName.includes('arm') || meshName.includes('hand') || meshName.includes('shoulder'))) ||
              (partId.includes('leg') && (meshName.includes('leg') || meshName.includes('thigh') || meshName.includes('foot')))
            ) {
              selectedObjects.push(object);
            }
          }
        });
        
        // Last resort: if still no objects found, just highlight any visible mesh
        if (selectedObjects.length === 0) {
          model.traverse((object) => {
            if (object.isMesh && object.visible) {
              selectedObjects.push(object);
            }
          });
        }
      }
      
      outlinePass.selectedObjects = selectedObjects;
      if (clickPoint) {
        updateTrackerPosition(clickPoint);
      }
      
      setTimeout(() => {
        updateSystemStatus('ACTIVE', 'green');
      }, 1000);
    }

    // --- Clear Body Part Selection ---
    function clearBodyPartSelection() {
      selectedPart = null;
      outlinePass.selectedObjects = [];
      hideTracker();
      
      // Reset the game display
      if (window.loadGame) {
        window.loadGame(null);
      }
    }

    // --- Update AR Labels Positions (Raised) ---
    function updateARLabelsPositions() {
      if (!model || !camera) return;
      // Adjusted positions for labels (raised y-values)
      const labelPositions = {
        head: new THREE.Vector3(0, 3.2, 0),
        torso: new THREE.Vector3(0.6, 2.2, 0),
        arm: new THREE.Vector3(-1.2, 1.8, 0),
        leg: new THREE.Vector3(0.6, 0.2, 0),
        abdomen: new THREE.Vector3(0, 1.4, 0.4) // Added abdomen label position
      };
      for (const [label, element] of Object.entries(arLabels)) {
        if (element && labelPositions[label]) {
          const position = labelPositions[label].clone();
          position.add(model.position);
          const vector = position.project(camera);
          const x = (vector.x * 0.5 + 0.5) * canvasContainer.clientWidth;
          const y = (-(vector.y * 0.5) + 0.5) * canvasContainer.clientHeight;
          element.style.left = (label.includes('right') ? x + 40 : x - 40) + 'px';
          element.style.top = y + 'px';
          element.style.display = vector.z < 1 ? 'block' : 'none';
        }
      }
    }

    // --- Animation Loop ---
    function animate() {
      requestAnimationFrame(animate);
      if (controls) {
        controls.update();
      }
      if (composer && scene && camera) {
        composer.render();
      }
      updateARLabelsPositions();
    }

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', init);
    } else {
      init();
    }
  </script>
</body>
</html>
          
